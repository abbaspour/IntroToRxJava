<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.oasis-open.org/docbook/xml/5.0b3/xsd/docbook.xsd">

    <title>Why RxJava?</title>

    <para>
        Users expect real time data. They want their tweets now. Their order confirmed now.
        They need prices accurate as of now. Their online games need to be responsive. As
        a developer, you demand fire-and-forget messaging. You don't want to be blocked
        waiting for a result. You want to have the result pushed to you when it is ready.
        Even better, when working with result sets, you want to receive individual results
        as they are ready. You do not want to wait for the entire set to be processed before
        you see the first row. The world has moved to push; users are waiting for us to
        catch up. Developers have tools to push data, this is easy. Developers need tools
        to react to push data.

    </para>

    <para>
        Welcome to
        <ulink url="https://github.com/ReactiveX/RxJava">Reactive Extensions for Java
        </ulink>
        (RxJava) a Java VM implementation of Reactive Extensions.
        a library for composing asynchronous and event-based programs by using observable sequences.
        It extends the observer pattern to support sequences of data/events and adds operators that
        allow you to compose sequences together declaratively while abstracting away concerns about
        things like low-level threading, synchronization, thread-safety and concurrent data structures.
    </para>

    <itemizedlist>
        <listitem>Zero Dependencies</listitem>
        <listitem>&lt; 700KB Jar</listitem>
        <listitem>Java 6+ &amp; Android 2.3+</listitem>
        <listitem>Java 8 lambda support</listitem>
        <!-- todo: links -->
        <listitem>Polyglot (Scala, Groovy, Clojure and Kotlin)</listitem>
        <listitem>Non-opinionated about source of concurrency (threads, pools, event loops, fibers, actors, etc)
        </listitem>
        <listitem>Async or synchronous execution</listitem>
        <listitem>Virtual time and schedulers for parameterized concurrency</listitem>
    </itemizedlist>

    <sect1>
        <title>When is RxJava appropriate?</title>
        <para>
            Rx offers a natural paradigm for dealing with sequences of events. A sequence can
            contain zero or more events. Rx proves to be most valuable when composing sequences
            of events.
        </para>

        <sect2>
            <title>Should use Rx</title>
            <para>
                Managing events like these is what Rx was built for:
            </para>

            <itemizedlist>
                <listitem>UI events like mouse move, button click</listitem>
                <listitem>Domain events like property changed, collection updated, "Order Filled", "Registration
                    accepted" etc.
                </listitem>
                <listitem>Infrastructure events like from file watcher, system and WMI events</listitem>
                <listitem>Integration events like a broadcast from a message bus or a push event from WebSockets
                    API or other low latency middleware like
                    <ulink url="http://www.my-channels.com">Nirvana</ulink>
                </listitem>
                <listitem>Integration with a CEP engine like
                    <ulink url="http://www.microsoft.com/sqlserver/en/us/solutions-technologies/business-intelligence/complex-event-processing.aspx">
                        StreamInsight
                    </ulink>
                    or<ulink url="http://www.streambase.com">StreamBase</ulink>.
                </listitem>
            </itemizedlist>

            <para>
                Rx is also very well suited for introducing and managing concurrency for the purpose
                of<emphasis>offloading</emphasis>. That is, performing a given set of work concurrently to free
                up the current thread. A very popular use of this is maintaining a responsive UI.
            </para>
            <!--
            <para>
                You should consider using Rx if you have an existing <tag>Enumerable&lt;T&gt;</tag>
                that is attempting to model data in motion. While <tag>IEnumerable&lt;T&gt;</tag>
                <emphasis>can</emphasis> model data in motion (by using lazy evaluation like <code>yield return</code>),
                it probably won't scale. Iterating over an <tag>IEnumerable&lt;T&gt;</tag> will consume/block
                a thread. You should either favor the non-blocking nature of Rx via either IObservable&lt;T&gt;
                or consider the <code>async</code> features in .NET 4.5.
            </para>
            -->
        </sect2>

        <sect2>
            <title>Could use Rx</title>
            <para>
                Rx can also be used for asynchronous calls. These are effectively sequences of one
                event.
            </para>

            <itemizedlist>
                <listitem>Result of a Task or Task&lt;T&gt;</listitem>
                <listitem>Result of an APM method call like
                    <tag>FileStream</tag>
                    BeginRead/EndRead
                </listitem>
            </itemizedlist>
            <para>
                You may find the using TPL, Dataflow or
                <code>async</code>
                keyword (.NET 4.5) proves
                to be a more natural way of composing asynchronous methods. While Rx can definitely
                help with these scenarios, if there are other more appropriate frameworks at your
                disposal you should consider them first.
            </para>
            <para>
                Rx can be used, but is less suited for, introducing and managing concurrency for
                the purposes of
                <emphasis>scaling</emphasis>
                or performing
                <emphasis>parallel</emphasis>
                computations. Other dedicated frameworks like TPL (Task Parallel Library) or C++ AMP
                are more appropriate for performing parallel compute intensive work.
            </para>
            <para>
                See more on TPL, Dataflow,
                <code>async</code>
                and C++ AMP at<ulink url="http://msdn.microsoft.com/en-us/concurrency">
                Microsoft's Concurrency homepage</ulink>.
            </para>
        </sect2>

        <sect2>
            <title>Won't use Rx</title>
            <para>
                Rx and specifically
                <tag>IObservable&lt;T&gt;</tag>
                is not a replacement for<tag>IEnumerable&lt;T&gt;</tag>.
                I would not recommend trying to take something that is naturally pull based and
                force it to be push based.
            </para>
            <itemizedlist>
                <listitem>Translating existing
                    <tag>IEnumerable&lt;T&gt;</tag>
                    values to
                    <tag>IObservable&lt;T&gt;</tag>
                    just so that the code base can be "more Rx"
                </listitem>
                <listitem>Message queues. Queues like in MSMQ or a JMS implementation generally have transactionality
                    and are by definition sequential. I feel
                    <tag>IEnumerable&lt;T&gt;</tag>
                    is a natural
                    fit for here.
                </listitem>
            </itemizedlist>
            <para>
                By choosing the best tool for the job your code should be easier to maintain, provide
                better performance and you will probably get better support.
            </para>
        </sect2>
    </sect1>


    <sect1>
        <title>RxJava in Action</title>

        <para>
            Adopting and learning RxJava can be an iterative approach where you can slowly apply
            it to your infrastructure and domain. In a short time you should be able to have
            the skills to produce code, or reduce existing code, to queries composed of simple
            operators. For example this simple ViewModel is all I needed to code to integrate
            a search that is to be executed as a user types.
        </para>

        <programlisting dir="ltr" language="java"
                        linenumbering="unnumbered">
            public class Test {
            public static void main() {
            int i;
            String s = "sample string";

            }
            }
        </programlisting>

    </sect1>

</chapter>